\documentclass{beamer}
\usepackage{pgfpages}
\setbeameroption{show notes on second screen}

\setbeamertemplate{navigation symbols}{}%remove navigation symbols
\mode<presentation>{}

\usepackage{tikz}
\usetikzlibrary{calc,shapes.multipart,chains,arrows,matrix,fit}
\usepackage{listings}
\usepackage{algpseudocode}

%% preamble
\title{Enhancements to Looping Constructs Using Prefetching and Exploiting GPU}
\author{Anurag Peshne}
\date{15 May 2018}

\begin{document}
%% title frame
\begin{frame}
  \titlepage
\end{frame}

%% normal frame
\begin{frame}{Contents}
  \note[item]{Agenda for today.}
  \pause
  \begin{itemize}
    \note[item]{First some background, what is SIA, how it works.}
  \item Super Instruction Architecture (SIA)
    \pause
    \note[item]{What we did.}
  \item 2 Enhancements
    \pause
    \begin{itemize}
    \item Prefetching
      \pause
    \item Exploiting GPU
      \pause
    \end{itemize}
    \note[item]{The experiments carried out to evaluate the work}
  \item Experiments
    \pause
  \item Conclusion
    \note[item]{And finally, the conclusions}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{SIA}
  \begin{itemize}
    \pause
  \item Parallel Programming Environment.
    \pause
  \item Engineered to solve very large computation problems expressed in terms of
    operation on multidimensional arrays.
    \pause
  \item Algorithms are expressed in terms of blocks or multidimensional arrays
    rather than individual floating point numbers:
    \begin{lstlisting}[]
      do i
        do j
          x = a[i,j] * b[i,j]
        enddo j
      enddo i
    \end{lstlisting}
    \pause
  \item \textit{Super} Instructions acting upon \textit{Super} Numbers.
  \end{itemize}
\end{frame}

\begin{frame}{SIA}
  \begin{itemize}
    \pause
  \item SIMD: can execute instructions in parallel over multiple processors.
    \note[item]{Blocks of same array distributed on different workers}
    \pause
  \item Can be deployed and scaled on multiple nodes in high performance computing cluster.
    \pause
  \item Can support arrays larger than combined memory of all nodes in cluster by
    swapping chunks that are not \textit{hot} on hard drive.
    \pause
  \item Participating nodes in cluster are divided into Servers and Workers:
    \begin{itemize}
      \pause
    \item Servers deal with swapping the blocks and serving the request for blocks
      by workers.
      \pause
    \item Workers do the actual computation.
      \note[item]{They request for specific block when needed.}
    \end{itemize}
    \pause
  \item SIA consists of:
    \begin{itemize}
      \pause
    \item Super Instruction Assembly Language (SIAL)
      \pause
    \item SIA Runtime
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{SIAL}
  \begin{itemize}
    \pause
  \item Domain Specific Language
    \pause
  \item Support for Blocks as first class citizen.
    \pause
  \item Intended to be used by domain programmer.
    \note[item]{High level, easy for domain programmer to code using it.}
    \pause
  \item Dynamically Interpreted.
    \note[item]{Interpreter can do tricks like executing on GPU if available or falling back to CPU if not}
    \pause
  \item \texttt{do} and \texttt{pardo}
    \pause
  \item Super Instructions can be defined using C, C++, Fortran
    \pause
    or CUDA.
    \note[item]{easy to port to CUDA}
  \end{itemize}
\end{frame}

\begin{frame}{Looping Constructs}
  \begin{itemize}
  \item \texttt{do}, \texttt{pardo}
    \note[item]{One of the most important constructs in language}
    \pause
  \item 2 Enhancements:
    \begin{itemize}
    \item Prefetching
    \item Exploiting GPU
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[label=prefetchcode]{Prefetching}
%\hline
\begin{algorithmic}[1]
%\caption{An example of typical workflow in SIAL}
\Loop
\State $GET\ A[i, j]$\Comment{Non Blocking}
\State $GET\ B[j, k]$
\State $t\_result[j, k] \gets A[i, j] \times B[j, k]$\Comment{Compute bound}
\State $CALL\ compute\_fun(t\_result[j, k])$
\State $PUT\ AB[i, k] \gets t\_result[i, k]$\Comment{Blocking Network bound}
\EndLoop
%\hline
\end{algorithmic}
\note[item]{Blocks at line 4: contraction.}
\note[item]{Compute resources wasted during network transfer, same in last line.
  PUT is blocking}
\note[item]{Network resources wasted during computing}
% Notes for 2 occurrence of this slide
\note[item]{------------------------------------------------------------------}
\note[item]{So for example, here \texttt{GET} on line 2 can prefetch independently
  of \texttt{GET} on line 3.}
\end{frame}

\begin{frame}{Prefetching}
  \begin{itemize}
  \item Similar to h/w prefetching:
    \note[item]{Explain h/w prefetching: how processor prefetches block of memory
      in anticipation that it will be needed}
    \begin{itemize}
      \pause
    \item Moving from slower memory to faster memory.
      \note[item]{RAM to cache memory; SIA: server memory to local client memory}
      \pause
    \item Need to guess what to prefetch \pause and how much to prefetch.
    \end{itemize}

    \pause
  \item Not exactly similar:
    \begin{itemize}
    \item In h/w there is anticipation, in SIA we \textit{know} precisely what to
      prefetch.
      \pause
    \item We know when to evict from cache.
      \note[item]{h/w may keep some blocks in memory in anticipation that it might
        be needed again}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Prefetching Implementation}
  \begin{itemize}
  \item Before prefetching:
    \begin{itemize}
    \item Get values of indices
    \item increment according to the loop
    \item Update values of indices
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Prefetching Implementation}
\begin{figure}
  \centering

  \tikzstyle{table}=[
  matrix of nodes,
  row sep=-\pgflinewidth,
  column sep=-\pgflinewidth,
  nodes={rectangle,draw=black,text width=12ex,align=center},
  text depth=0.25ex,
  text height=1.5ex,
  nodes in empty cells]
  \begin{tikzpicture}[list/.style={rectangle split, rectangle split parts=6,
      draw, rectangle split horizontal}, >=stealth, start chain]

    \node[list,on chain] (A) {};
    \note[item]{Here we first calculate the set of indices}
    \pause
    \node[list,on chain] (B) {};
    \note[item]{Then calculate next set using previous set, before actually iterating over the loop}
    \pause
    \node[list,on chain] (C) {};
    \note[item]{And so on...}
    \pause
    \node[on chain,draw,inner sep=6pt] (D) {};
    \draw (D.north east) -- (D.south west);
    \draw (D.north west) -- (D.south east);
    \draw[*->] let \p1 = (A.six), \p2 = (A.center) in (\x1,\y2) -- (B);
    \draw[*->] let \p1 = (B.six), \p2 = (B.center) in (\x1,\y2) -- (C);
    \draw[*->] let \p1 = (C.six), \p2 = (C.center) in (\x1,\y2) -- (D);

    \note[item]{Creating list of indices}
    \pause
    \matrix (map) [table,below=of A]
    {
      LineNumber & Reference  \\
      101        &            \\
      102        &            \\
      \vdots     & \vdots     \\
    };

    \note[item]{Save which set of indices is prefetched by each \texttt{GET} in the loop}
    \pause
    \draw[*->] (map-2-2.center) to[out=0, in=270] (B.south);
    \pause
    \draw[*->] (map-3-2.center) to[out=0, in=270] (C.south);
  \end{tikzpicture}
\end{figure}
\end{frame}

\againframe{prefetchcode}

\begin{frame}{Prefetching Mechanism}
  \begin{itemize}
  \item Function \texttt{update\_indices} divided into 3 functions:
    \begin{itemize}
      \pause
    \item \texttt{peek\_indices}
      \note[item]{returns set of indices, internally taking care of maintaining
        and generating next indices lazily if required}
      \pause
    \item \texttt{prefetch\_indices}
      \note[item]{remembers the state of each \texttt{GET} and automatically returns
        next set of indices for each \texttt{GET}}
      \pause
    \item \texttt{update}
      \note[item]{pops the first element in the list and updates the interpreter
        state}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Prefetching Mechanism}
  \begin{figure}[h] %place figure "here"
    \centering
    \begin{tikzpicture}[
      list/.style={rectangle split, rectangle split parts=7,
        draw, rectangle split horizontal},
      function/.style={rectangle, draw,align=center},
      >=stealth, start chain]

      \node[list,on chain] (A) {};
      \node[list,on chain] (B) {};
      \node[list,on chain] (C) {};
      \node[on chain,draw,inner sep=6pt] (D) {};
      \draw (D.north east) -- (D.south west);
      \draw (D.north west) -- (D.south east);
      \draw[*->] let \p1 = (A.seven), \p2 = (A.center) in (\x1,\y2) -- (B);
      \draw[*->] let \p1 = (B.seven), \p2 = (B.center) in (\x1,\y2) -- (C);
      \draw[*->] let \p1 = (C.seven), \p2 = (C.center) in (\x1,\y2) -- (D);

      \note[item]{We have same list from last time}
      \pause
      \node[function, below=of A]        (update)   {\texttt{update}};
      \node[function, right=of update]   (prefetch) {\texttt{prefetch\_indices}};
      \node[function, right=of prefetch] (peek)     {\texttt{peek\_indices}};

      \draw[->]                (update.north)   -- (A.south);
      \draw[densely dotted,->] (prefetch.north) -- (A.south);
      \draw[densely dotted,->] (prefetch.north) -- (B.south);
      \draw[densely dotted,->] (prefetch.north) -- (C.south);
      \draw[->]                (peek.north)     -- (C.south);

      \note[item]{\texttt{peek\_indices} produced, \texttt{prefetch\_indices} is
        free to roam along the list, \texttt{update} consumes a set of indices from
        the list.}
    \end{tikzpicture}
  \end{figure}
\end{frame}

\begin{frame}{Hit Ratio}
  \note[item]{To study the effectiveness of the prefetching, \texttt{hit\_ratio},
    another metric is introduced.}
  \pause
  \[
    \texttt{hit\_ratio} = \frac{number~of~times~no~blocking~required}{total~number~of~times~data~accessed}
  \]
  \note[item]{The \texttt{hit\_ratio} represents the number of times prefetching
    was successful to hide network transfer cost.}
\end{frame}

\begin{frame}{Prefetching Experiments: Index Length}
  \note[item]{Index length is the length of range of indices: when looping on
    \texttt{i}, it goes from 2 to 5 or 2 to 10}
  \pause
  \begin{figure}[h]
    \resizebox{.9\linewidth}{!}{\input{results/index_length/hitratio}}
    \caption{Index Range Length v/s \texttt{hit\_ratio}}
  \end{figure}
  \note[item]{Several things to note: the lowest hit ratio is 0.65, because...}
  \note[item]{as the lenght of range of indices increase, the prefetching kicks in}
  \note[item]{eventually flattens out}
\end{frame}

\begin{frame}{Prefetching Experiments: First Iteration}
  \note[item]{Side effect of prefetching: with prefetching, the first request becomes
    heavy}
  \pause
  \begin{figure}[h]
    \resizebox{.9\linewidth}{!}{\input{results/index_length/p_first_mean}}
    \caption{Index Range v/s \texttt{wait\_time\_} per iteration}
  \end{figure}
  \note[item]{As prefetching kicks in, the first request becomes costlier}
  \note[item]{note mean is reducing}
  \note[item]{looking other way round, prefetching is kicking in}
\end{frame}

\begin{frame}{Prefetching Experiments: Mean}
  \note[item]{Overal wait time by \texttt{GET}}
  \pause
  \begin{figure}[h]
    \resizebox{.9\linewidth}{!}{\input{results/index_length/p_np_mean}}
    \caption{Index Range v/s \texttt{wait\_time\_} per iteration in Prefetched and no Prefetched Loop}
  \end{figure}
  \note[item]{Prefetching helps!}
\end{frame}

\begin{frame}{Prefetching Experiments: Block Size First Iteration}
  \note[item]{How block size affects first iteration}
  \pause
  \begin{figure}[h]
    \resizebox{.9\linewidth}{!}{\input{results/block_size/first_wait_time}}
    \caption{Block Size v/s \texttt{wait\_time\_} for first iteration}
  \end{figure}
  \note[item]{block size affects first iteration}
\end{frame}

\begin{frame}{Prefetching Experiments: Block Size Mean}
  \note[item]{How block size affects overall time}
  \pause
  \begin{figure}[h]
    \resizebox{.9\linewidth}{!}{\input{results/block_size/avg_wait_time}}
    \caption{Block Size v/s Mean \texttt{wait\_time\_} for Prefetched and No Prefetch Loop}
  \end{figure}
  \note[item]{Prefetching is paying off, 'Prefetch' time not so much affected}
\end{frame}

\begin{frame}{Prefetching: Putting it all together}
  \note[item]{Just to look at whole picture}
  \pause
  \begin{figure}[h]
    \resizebox{.9\linewidth}{!}{\input{results/block_size/avg_all}}
    \caption{Block Size v/s Mean \texttt{wait\_time\_} for Prefetched and No Prefetch Loop}
  \end{figure}
\end{frame}

\begin{frame}{Prefetching: Number of Blocks to Prefetch}
  \note[item]{\texttt{wait\_time} for the \textbf{first} iteration}
  \pause
  \begin{figure}[h]
    \resizebox{.9\linewidth}{!}{\input{results/look_ahead/first_wait_time}}
    \caption{Number of Block Prefetched v/s \texttt{wait\_time\_} for first request}
  \end{figure}

  \note[item]{\texttt{wait\_time\_} for the first request grows linearly with the
    number of blocks to prefetch}
  \note[item]{Thus the number of blocks to prefetch cannot be set at very high
    number unless the length of index range is known to be large}
\end{frame}

\begin{frame}{Prefetching: Number of Blocks to Prefetch}
  \note[item]{This time to overall mean \texttt{wait\_time}}
  \pause
  \begin{figure}[h]
    \resizebox{.9\linewidth}{!}{\input{results/look_ahead/avg_wait_time}}
    \caption{Number of Block Prefetched v/s mean \texttt{wait\_time\_}}
  \end{figure}
  \note[item]{First sharp decrease as prefetching kicks in then increase due to
    costly first iteration}
\end{frame}

\begin{frame}{Prefetching: Number of Blocks to Prefetch}
  \note[item]{now lets look at this number v/s hit ratio}
  \pause
  \begin{figure}[h]
    \resizebox{.9\linewidth}{!}{\input{results/look_ahead/hit_ratio}}
    \caption{Number of Block Prefetched v/s Hit Ratio for first request}
    \label{fig:look_ahead_hit_ratio}
  \end{figure}
  \note[item]{Hit ratio saturates after hitting a critical amount. There is no
    much use after that to increase number of blocks to prefetch.}
  \note[item]{This explains the rise in mean \texttt{wait\_time\_} as
    \texttt{wait\_time\_} for first request grows and the number of blocks
    available without blocking stays constant.}
\end{frame}

\end{document}
\documentclass{beamer}
\usepackage{pgfpages}
\setbeameroption{show notes on second screen}

\setbeamertemplate{navigation symbols}{}%remove navigation symbols
\mode<presentation>{}

\usepackage{tikz}
\usetikzlibrary{calc,shapes.multipart,chains,arrows,matrix,fit}
\usepackage{listings}
\usepackage{algpseudocode}

%% preamble
\title{Enhancements to Looping Constructs Using Prefetching and Exploiting GPU}
\author{Anurag Peshne}
\date{15 May 2018}

\begin{document}
%% title frame
\begin{frame}
  \titlepage
\end{frame}

%% normal frame
\begin{frame}{Contents}
  \note[item]{Agenda for today.}
  \pause
  \begin{itemize}
    \note[item]{First some background, what is SIA, how it works.}
  \item Super Instruction Architecture (SIA)
    \pause
    \note[item]{What we did.}
  \item 2 Enhancements
    \pause
    \begin{itemize}
    \item Prefetching
      \pause
    \item Exploiting GPU
      \pause
    \end{itemize}
    \note[item]{The experiments carried out to evaluate the work}
  \item Experiments
    \pause
  \item Conclusion
    \note[item]{And finally, the conclusions}
  \end{itemize}
\end{frame}

\begin{frame}[fragile]{SIA}
  \begin{itemize}
    \pause
  \item Parallel Programming Environment.
    \pause
  \item Engineered to solve very large computation problems expressed in terms of
    operation on multidimensional arrays.
    \pause
  \item Algorithms are expressed in terms of blocks or multidimensional arrays
    rather than individual floating point numbers:
    \begin{lstlisting}[]
      do i
        do j
          x = a[i,j] * b[i,j]
        enddo j
      enddo i
    \end{lstlisting}
    \pause
  \item \textit{Super} Instructions acting upon \textit{Super} Numbers.
  \end{itemize}
\end{frame}

\begin{frame}{SIA}
  \begin{itemize}
    \pause
  \item SIMD: can execute instructions in parallel over multiple processors.
    \note[item]{Blocks of same array distributed on different workers}
    \pause
  \item Can be deployed and scaled on multiple nodes in high performance computing cluster.
    \pause
  \item Can support arrays larger than combined memory of all nodes in cluster by
    swapping chunks that are not \textit{hot} on hard drive.
    \pause
  \item Participating nodes in cluster are divided into Servers and Workers:
    \begin{itemize}
      \pause
    \item Servers deal with swapping the blocks and serving the request for blocks
      by workers.
      \pause
    \item Workers do the actual computation.
      \note[item]{They request for specific block when needed.}
    \end{itemize}
    \pause
  \item SIA consists of:
    \begin{itemize}
      \pause
    \item Super Instruction Assembly Language (SIAL)
      \pause
    \item SIA Runtime
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{SIAL}
  \begin{itemize}
    \pause
  \item Domain Specific Language
    \pause
  \item Support for Blocks as first class citizen.
    \pause
  \item Intended to be used by domain programmer.
    \note[item]{High level, easy for domain programmer to code using it.}
    \pause
  \item Dynamically Interpreted.
    \note[item]{Interpreter can do tricks like executing on GPU if available or falling back to CPU if not}
    \pause
  \item \texttt{do} and \texttt{pardo}
    \pause
  \item Super Instructions can be defined using C, C++, Fortran
    \pause
    or CUDA.
    \note[item]{easy to port to CUDA}
  \end{itemize}
\end{frame}

\begin{frame}{Looping Constructs}
  \begin{itemize}
  \item \texttt{do}, \texttt{pardo}
    \note[item]{One of the most important constructs in language}
    \pause
  \item 2 Enhancements:
    \begin{itemize}
    \item Prefetching
    \item Exploiting GPU
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}[label=prefetchcode]{Prefetching}
%\hline
\begin{algorithmic}[1]
%\caption{An example of typical workflow in SIAL}
\Loop
\State $GET\ A[i, j]$\Comment{Non Blocking}
\State $GET\ B[j, k]$
\State $t\_result[j, k] \gets A[i, j] \times B[j, k]$\Comment{Compute bound}
\State $CALL\ compute\_fun(t\_result[j, k])$
\State $PUT\ AB[i, k] \gets t\_result[i, k]$\Comment{Blocking Network bound}
\EndLoop
%\hline
\end{algorithmic}
\note[item]{Blocks at line 4: contraction.}
\note[item]{Compute resources wasted during network transfer, same in last line.
  PUT is blocking}
\note[item]{Network resources wasted during computing}
% Notes for 2 occurrence of this slide
\note[item]{------------------------------------------------------------------}
\note[item]{So for example, here \texttt{GET} on line 2 can prefetch independently
  of \texttt{GET} on line 3.}
\end{frame}

\begin{frame}{Prefetching}
  \begin{itemize}
  \item Similar to h/w prefetching:
    \note[item]{Explain h/w prefetching: how processor prefetches block of memory
      in anticipation that it will be needed}
    \begin{itemize}
      \pause
    \item Moving from slower memory to faster memory.
      \note[item]{RAM to cache memory; SIA: server memory to local client memory}
      \pause
    \item Need to guess what to prefetch \pause and how much to prefetch.
    \end{itemize}

    \pause
  \item Not exactly similar:
    \begin{itemize}
    \item In h/w there is anticipation, in SIA we \textit{know} precisely what to
      prefetch.
      \pause
    \item We know when to evict from cache.
      \note[item]{h/w may keep some blocks in memory in anticipation that it might
        be needed again}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Prefetching Implementation}
  \begin{itemize}
  \item Before prefetching:
    \begin{itemize}
    \item Get values of indices
    \item increment according to the loop
    \item Update values of indices
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Prefetching Implementation}
\begin{figure}
  \centering

  \tikzstyle{table}=[
  matrix of nodes,
  row sep=-\pgflinewidth,
  column sep=-\pgflinewidth,
  nodes={rectangle,draw=black,text width=12ex,align=center},
  text depth=0.25ex,
  text height=1.5ex,
  nodes in empty cells]
  \begin{tikzpicture}[list/.style={rectangle split, rectangle split parts=6,
      draw, rectangle split horizontal}, >=stealth, start chain]

    \node[list,on chain] (A) {};
    \note[item]{Here we first calculate the set of indices}
    \pause
    \node[list,on chain] (B) {};
    \note[item]{Then calculate next set using previous set, before actually iterating over the loop}
    \pause
    \node[list,on chain] (C) {};
    \note[item]{And so on...}
    \pause
    \node[on chain,draw,inner sep=6pt] (D) {};
    \draw (D.north east) -- (D.south west);
    \draw (D.north west) -- (D.south east);
    \draw[*->] let \p1 = (A.six), \p2 = (A.center) in (\x1,\y2) -- (B);
    \draw[*->] let \p1 = (B.six), \p2 = (B.center) in (\x1,\y2) -- (C);
    \draw[*->] let \p1 = (C.six), \p2 = (C.center) in (\x1,\y2) -- (D);

    \note[item]{Creating list of indices}
    \pause
    \matrix (map) [table,below=of A]
    {
      LineNumber & Reference  \\
      101        &            \\
      102        &            \\
      \vdots     & \vdots     \\
    };

    \note[item]{Save which set of indices is prefetched by each \texttt{GET} in the loop}
    \pause
    \draw[*->] (map-2-2.center) to[out=0, in=270] (B.south);
    \pause
    \draw[*->] (map-3-2.center) to[out=0, in=270] (C.south);
  \end{tikzpicture}
\end{figure}
\end{frame}

\againframe{prefetchcode}

\begin{frame}{Prefetching Mechanism}
  \begin{itemize}
  \item Function \texttt{update\_indices} divided into 3 functions:
    \begin{itemize}
      \pause
    \item \texttt{peek\_indices}
      \note[item]{returns set of indices, internally taking care of maintaining
        and generating next indices lazily if required}
      \pause
    \item \texttt{prefetch\_indices}
      \note[item]{remembers the state of each \texttt{GET} and automatically returns
        next set of indices for each \texttt{GET}}
      \pause
    \item \texttt{update}
      \note[item]{pops the first element in the list and updates the interpreter
        state}
    \end{itemize}
  \end{itemize}
\end{frame}

\begin{frame}{Prefetching Mechanism}
  \begin{figure}[h] %place figure "here"
    \centering
    \begin{tikzpicture}[
      list/.style={rectangle split, rectangle split parts=7,
        draw, rectangle split horizontal},
      function/.style={rectangle, draw,align=center},
      >=stealth, start chain]

      \node[list,on chain] (A) {};
      \node[list,on chain] (B) {};
      \node[list,on chain] (C) {};
      \node[on chain,draw,inner sep=6pt] (D) {};
      \draw (D.north east) -- (D.south west);
      \draw (D.north west) -- (D.south east);
      \draw[*->] let \p1 = (A.seven), \p2 = (A.center) in (\x1,\y2) -- (B);
      \draw[*->] let \p1 = (B.seven), \p2 = (B.center) in (\x1,\y2) -- (C);
      \draw[*->] let \p1 = (C.seven), \p2 = (C.center) in (\x1,\y2) -- (D);

      \note[item]{We have same list from last time}
      \pause
      \node[function, below=of A]        (update)   {\texttt{update}};
      \node[function, right=of update]   (prefetch) {\texttt{prefetch\_indices}};
      \node[function, right=of prefetch] (peek)     {\texttt{peek\_indices}};

      \draw[->]                (update.north)   -- (A.south);
      \draw[densely dotted,->] (prefetch.north) -- (A.south);
      \draw[densely dotted,->] (prefetch.north) -- (B.south);
      \draw[densely dotted,->] (prefetch.north) -- (C.south);
      \draw[->]                (peek.north)     -- (C.south);

      \note[item]{\texttt{peek\_indices} produced, \texttt{prefetch\_indices} is
        free to roam along the list, \texttt{update} consumes a set of indices from
        the list.}
    \end{tikzpicture}
  \end{figure}
\end{frame}

\end{document}